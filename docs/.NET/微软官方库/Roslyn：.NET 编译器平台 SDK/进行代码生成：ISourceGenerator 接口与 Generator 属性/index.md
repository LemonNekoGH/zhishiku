
<p id="t7neeqRiZaBgB3TWnpyLJj">

有时候，会为了节省重复代码等等需求，编写代码生成器来生成这些代码，在编译时，这些代码就会被生成并且编译到目标程序中。

</p>

<p id="5g62NrUG2hX9bRx2gs7adZ">

我们这次来实现一个生成器，它会帮目标程序的主程序实现一个加法函数。

</p>

<p id="qgyU23NjNdieW9etBbKs6r">

## 初始化

</p>

<p id="XLATdxWZBHXtfZBn3EJFU">

假设这个项目名称是：`SourceGeneratorCode`

</p>

<p id="x2Y2UeWXrwuR5qJJePjp2t">

安装依赖：

</p>

<p id="7C6KNSsgs4F29cTbmJcfbM">

```Bash
$ dotnet add package Microsoft.CodeAnalysis.CSharp
$ dotnet add package Microsoft.CodeAnalysis.Analyzers
```


</p>

<p id="waEniUdwvmVLzSee1cLk3n">

安装完成后，项目描述文件`.csproj`中会有类似以下依赖：

</p>

<p id="vWQ5TumjPp2MMkhoQ6aoQK">

```XML
<ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" PrivateAssets="all" />
    <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.4" PrivateAssets="all" />
</ItemGroup>
```


</p>

<p id="obggNgPVaCcJgc2bxB9jsp">

在项目描述文件中添加以下属性以启用代码分析扩展：

</p>

<p id="k54RUNLtYWLWcE1VsxtbqF">

```XML
<PropertyGroup>
  <EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
</PropertyGroup>
```


</p>

<p id="gGTxqCzCZwFE8oKnrabh6e">

假设另一个项目名称是：`SourceGeneratorPlayground`

</p>

<p id="71UshxbuWVAg88ads8xAV9">

在依赖中加入代码生成器：

</p>

<p id="iLWirwj5uJAy1K6uqgneTN">

```C#
<ItemGroup>
    <ProjectReference 
      Include="../SourceGeneratorCode" 
      PrivateAssets="all"
      OutputItemType="Analyzer"
      ReferenceOutputAssembly="false" />
</ItemGroup>
```


</p>

<p id="9UN8ceA2xfcZz53NrxEMyz">

其中，`OutputItemType`用于指定依赖在编译时用于做什么，`ReferenceOutputAssembly`用于指定是否引用依赖的`Assembly`文件。

</p>

<p id="iAnCToakByaJ2QMBZh9H1M">

如果想要知道代码生成器到底生成了什么文件，可以在项目描述文件中加入属性：

</p>

<p id="gfWoQz9UdmTyv6BrtT264s">

```XML
<PropertyGroup>
    <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles> <!-- 告诉编译器把生成的代码写入文件 -->
</PropertyGroup>
```


</p>

<p id="25vqE3MLEymFNyozAHauug">

## 编写`SourceGeneratorPlayground`的主程序

</p>

<p id="7jjHyfVdatFY3h5VXM2uCf">

文件：`Program.cs`

</p>

<p id="qLgeoBGoXmebe9Wx9LCfqu">

```C#
public static partial class Program { // partial 关键字很重要，表示在其它地方也有这个类的内容，有了这个关键字之后，生成的代码就可以在这个文件中使用
  public static void Main() {
    Console.WriteLine(Add(1, 2));
  }
  
  static partial void Add(int a, int b); // 此处的 partial 关键字表示这个函数会在其它文件中被实现
}
```


</p>

<p id="6S9mz4TajCosWsYEqV7sjD">

需要被实现的`Add(int a, int b)`函数不能被`public`修饰，因为另一个类也只能存在于相同的命名空间，因此`public`修饰符无意义，如果希望被其它命名空间的代码调用，可以写一个包装函数。

</p>

<p id="s41fqbtVQWYXa78VBgGPYw">

## 编写代码生成器

</p>

<p id="7pxb5YAN6EniNzBk1PTwoc">

假设另一个项目名称是：`SourceGeneratorPlayground`

</p>

<p id="dNmtwaZbfrUJ9wQKkpc4xY">

我们编写一个生成器，来实现`Add(int a, int b)`

</p>

<p id="hZ6eWZ3obc6vkHQJ7MdAoM">

```C#
namespace SourceGeneratorCode;

[Generator]
public class CustomSourceGenerator : ISourceGenerator {
    public void Execute(GeneratorExecutionContext context)
    {
        string source = $@"// <auto-generated/>
namespace SourceGeneratorPlayground;

public static partial class Program
{{
    static partial void Add(int a, int b) => a + b;
}}
";
        // 将代码加入到目标程序中
        context.AddSource($"Program.g.cs", source);
    }

    public void Initialize(GeneratorInitializationContext context) {}
}
```


</p>

<p id="7KcYWohou6ptPwFok9ecsb">

请注意：

</p>

1. 在文件头部加入`// <auto-generated/>`或者类似注释，表示此代码是被生成的，不希望被修改。

1. 实现的`Add(int a, int b)`函数也需要被`partial`修饰，否则编译时会报错：`Add`函数已经被定义。

1. 生成的代码文件命名为`*.generted.cs`或者`*.g.cs`，这样也可以二次提醒这个文件是被生成的。

1. 这个示例不是通用的，只能为`SourceGeneratorPlayground`命名空间中的`Program`类中生成`Add(int a, int b)`的实现。

<p id="xrNuyqPR1n6NYLAZC1YdxC">

## 运行目标项目

</p>

<p id="qhUCzWJt9YuJ4ZuLiUjVic">

```Bash
$ dotnet run
# output: 3
```


</p>

<p id="tEqF6eroLqYQZc34pVtMAK">

可以在`.generated`文件夹中发现`Program.g.cs`，内容就是刚刚写的：

</p>

<p id="wDU7n7jcDSwmM3bKintjza">

```C#
// <auto-generated/>
namespace SourceGeneratorPlayground;

public static partial class Program
{
    static partial void Add(int a, int b) => a + b;
}
```


</p>

<p id="w6XDp5x1nsL2ZmJZiUHhjC">

## 问题解决

</p>

- 修改生成器之后，生成的代码却是旧代码生成器的生成结果。
